license-plate-recognition/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ lpr_system.py
â”‚   â”œâ”€â”€ database.py
â”‚   â”œâ”€â”€ notification_service.py
â”‚   â”œâ”€â”€ image_enhancement.py
â”‚   â””â”€â”€ requirements.txt
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â””â”€â”€ package.json
â”œâ”€â”€ test_images/
â””â”€â”€ README.md
1. Enhanced Backend System
backend/requirements.txt
txt
opencv-python==4.8.1.78
pytesseract==0.3.10
numpy==1.24.3
sqlite3
python-telegram-bot==20.7
twilio==8.10.0
flask==2.3.3
flask-cors==4.0.0
requests==2.31.0
Pillow==10.0.0
scikit-image==0.21.0
backend/lpr_system.py
python
import cv2
import numpy as np
import pytesseract
import sqlite3
import time
import logging
from datetime import datetime
from image_enhancement import ImageEnhancer

class LicensePlateRecognition:
    def __init__(self):
        self.enhancer = ImageEnhancer()
        self.setup_tesseract()
        self.setup_logging()
        
    def setup_tesseract(self):
        """Configure Tesseract OCR path"""
        pytesseract.pytesseract.tesseract_cmd = r'C:\\Program Files\\Tesseract-OCR\\tesseract.exe'
        
    def setup_logging(self):
        """Setup logging for the system"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('lpr_system.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def detect_license_plate(self, image_path, enhance_for_weather=False):
        """
        Enhanced license plate detection with weather adaptation
        """
        try:
            # Load image
            image = cv2.imread(image_path)
            if image is None:
                self.logger.error(f"Could not load image: {image_path}")
                return None, None, None
                
            # Apply weather enhancement if needed
            if enhance_for_weather:
                image = self.enhancer.enhance_for_fog(image)
                image = self.enhancer.enhance_contrast(image)
                
            # Convert to grayscale
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            # Apply advanced preprocessing
            processed = self.enhancer.preprocess_image(gray)
            
            # Multiple detection strategies
            plates = []
            
            # Strategy 1: Contour-based detection
            plates.extend(self._detect_by_contours(processed, image))
            
            # Strategy 2: Edge-based detection
            plates.extend(self._detect_by_edges(processed, image))
            
            # Strategy 3: Morphology-based detection
            plates.extend(self._detect_by_morphology(processed, image))
            
            if not plates:
                self.logger.warning("No license plates detected")
                return image, None, None
                
            # Select the best candidate
            best_plate = self._select_best_plate(plates)
            
            return image, best_plate['plate'], best_plate['contour']
            
        except Exception as e:
            self.logger.error(f"Error in license plate detection: {str(e)}")
            return None, None, None
            
    def _detect_by_contours(self, processed, original):
        """Detect plates using contour analysis"""
        plates = []
        
        # Find contours
        contours, _ = cv2.findContours(processed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        contours = sorted(contours, key=cv2.contourArea, reverse=True)[:10]
        
        for contour in contours:
            perimeter = cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, 0.018 * perimeter, True)
            
            if len(approx) == 4:
                x, y, w, h = cv2.boundingRect(contour)
                aspect_ratio = w / float(h)
                
                # Flexible aspect ratio for different plate types
                if 2.0 <= aspect_ratio <= 6.0 and 1000 <= (w * h) <= 50000:
                    plate_region = original[y:y+h, x:x+w]
                    plates.append({
                        'plate': plate_region,
                        'contour': approx,
                        'confidence': self._calculate_confidence(plate_region),
                        'method': 'contour'
                    })
                    
        return plates
        
    def _detect_by_edges(self, processed, original):
        """Detect plates using edge detection"""
        plates = []
        
        # Enhanced edge detection
        edges = cv2.Canny(processed, 50, 150)
        
        # Dilate edges to connect broken lines
        kernel = np.ones((3,3), np.uint8)
        edges = cv2.dilate(edges, kernel, iterations=1)
        
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        for contour in contours:
            area = cv2.contourArea(contour)
            if 1000 <= area <= 50000:
                x, y, w, h = cv2.boundingRect(contour)
                aspect_ratio = w / float(h)
                
                if 2.0 <= aspect_ratio <= 6.0:
                    plate_region = original[y:y+h, x:x+w]
                    plates.append({
                        'plate': plate_region,
                        'contour': contour,
                        'confidence': self._calculate_confidence(plate_region),
                        'method': 'edge'
                    })
                    
        return plates
        
    def _detect_by_morphology(self, processed, original):
        """Detect plates using morphological operations"""
        plates = []
        
        # Create rectangular kernel for license plate shape
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (13, 5))
        morph = cv2.morphologyEx(processed, cv2.MORPH_CLOSE, kernel)
        
        contours, _ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        for contour in contours:
            area = cv2.contourArea(contour)
            if 2000 <= area <= 40000:
                x, y, w, h = cv2.boundingRect(contour)
                plate_region = original[y:y+h, x:x+w]
                plates.append({
                    'plate': plate_region,
                    'contour': contour,
                    'confidence': self._calculate_confidence(plate_region),
                    'method': 'morphology'
                })
                
        return plates
        
    def _calculate_confidence(self, plate_region):
        """Calculate confidence score for plate detection"""
        if plate_region is None or plate_region.size == 0:
            return 0
            
        # Convert to grayscale if needed
        if len(plate_region.shape) == 3:
            gray_plate = cv2.cvtColor(plate_region, cv2.COLOR_BGR2GRAY)
        else:
            gray_plate = plate_region
            
        # Calculate contrast score
        contrast = np.std(gray_plate)
        
        # Calculate edge density
        edges = cv2.Canny(gray_plate, 50, 150)
        edge_density = np.sum(edges) / (gray_plate.shape[0] * gray_plate.shape[1])
        
        # Combined confidence score
        confidence = (contrast / 50 + edge_density * 100) / 2
        return min(confidence, 100)
        
    def _select_best_plate(self, plates):
        """Select the best plate candidate based on confidence"""
        return max(plates, key=lambda x: x['confidence'])
        
    def extract_text_from_plate(self, license_plate_image):
        """
        Extract text from license plate with multiple OCR strategies
        """
        if license_plate_image is None:
            return "", 0
            
        try:
            # Preprocess plate for OCR
            processed_plate = self.enhancer.preprocess_for_ocr(license_plate_image)
            
            # Try multiple OCR configurations
            texts = []
            confidences = []
            
            # Strategy 1: Single line
            text1 = pytesseract.image_to_string(processed_plate, config='--psm 8 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
            texts.append(text1.strip())
            
            # Strategy 2: Single word
            text2 = pytesseract.image_to_string(processed_plate, config='--psm 8')
            texts.append(text2.strip())
            
            # Strategy 3: Multiple lines
            text3 = pytesseract.image_to_string(processed_plate, config='--psm 7')
            texts.append(text3.strip())
            
            # Get confidence for the best result
            data = pytesseract.image_to_data(processed_plate, output_type=pytesseract.Output.DICT, config='--psm 8')
            if data['conf']:
                confidence = np.mean([conf for conf in data['conf'] if conf > 0])
            else:
                confidence = 0
                
            # Clean and select best text
            cleaned_texts = [self._clean_plate_text(text) for text in texts if text]
            best_text = max(cleaned_texts, key=len) if cleaned_texts else ""
            
            return best_text, confidence
            
        except Exception as e:
            self.logger.error(f"OCR Error: {str(e)}")
            return "", 0
            
    def _clean_plate_text(self, text):
        """Clean and validate license plate text"""
        import re
        
        # Remove unwanted characters
        cleaned = re.sub(r'[^A-Z0-9]', '', text.upper())
        
        # Basic validation
        if 4 <= len(cleaned) <= 10:  # Reasonable plate length
            return cleaned
        return ""
        
    def calculate_accuracy(self, detected_text, expected_text):
        """Calculate accuracy using Levenshtein distance"""
        if not detected_text or not expected_text:
            return 0
            
        # Simple character-based accuracy
        expected_upper = expected_text.upper().replace(' ', '')
        detected_upper = detected_text.upper().replace(' ', '')
        
        correct_chars = sum(1 for a, b in zip(detected_upper, expected_upper) if a == b)
        max_len = max(len(detected_upper), len(expected_upper))
        
        return (correct_chars / max_len) * 100 if max_len > 0 else 0
backend/image_enhancement.py
python
import cv2
import numpy as np
from skimage import exposure, filters
import logging

class ImageEnhancer:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    def preprocess_image(self, image):
        """Advanced image preprocessing"""
        # Multiple enhancement techniques
        enhanced = self.enhance_contrast(image)
        enhanced = self.reduce_noise(enhanced)
        enhanced = self.sharpen_image(enhanced)
        
        # Adaptive thresholding
        binary = cv2.adaptiveThreshold(
            enhanced, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
            cv2.THRESH_BINARY, 11, 2
        )
        
        return binary
        
    def enhance_contrast(self, image):
        """Enhance image contrast using CLAHE"""
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
        return clahe.apply(image) if len(image.shape) == 2 else clahe.apply(cv2.cvtColor(image, cv2.COLOR_BGR2GRAY))
        
    def reduce_noise(self, image):
        """Reduce noise while preserving edges"""
        return cv2.bilateralFilter(image, 9, 75, 75)
        
    def sharpen_image(self, image):
        """Sharpen image using kernel convolution"""
        kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
        return cv2.filter2D(image, -1, kernel)
        
    def enhance_for_fog(self, image):
        """Enhance image for foggy/misty conditions"""
        # Convert to LAB color space
        lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
        l, a, b = cv2.split(lab)
        
        # Apply CLAHE to L channel
        clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))
        l_enhanced = clahe.apply(l)
        
        # Merge channels and convert back
        lab_enhanced = cv2.merge([l_enhanced, a, b])
        enhanced = cv2.cvtColor(lab_enhanced, cv2.COLOR_LAB2BGR)
        
        # Dehazing using dark channel prior (simplified)
        enhanced = self.simplified_dehaze(enhanced)
        
        return enhanced
        
    def simplified_dehaze(self, image):
        """Simplified dehazing algorithm"""
        # Estimate atmospheric light
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        atmospheric_light = np.percentile(gray, 95)
        
        # Calculate transmission map
        transmission = 1 - 0.95 * (gray / atmospheric_light)
        transmission = np.clip(transmission, 0.1, 0.9)
        
        # Recover scene radiance
        result = np.zeros_like(image, dtype=np.float32)
        for i in range(3):
            result[:,:,i] = (image[:,:,i].astype(np.float32) - atmospheric_light) / transmission + atmospheric_light
            
        return np.clip(result, 0, 255).astype(np.uint8)
        
    def preprocess_for_ocr(self, plate_image):
        """Preprocess license plate specifically for OCR"""
        if len(plate_image.shape) == 3:
            gray = cv2.cvtColor(plate_image, cv2.COLOR_BGR2GRAY)
        else:
            gray = plate_image
            
        # Resize for better OCR
        height, width = gray.shape
        if height < 50:
            scale = 50 / height
            new_width = int(width * scale)
            gray = cv2.resize(gray, (new_width, 50), interpolation=cv2.INTER_CUBIC)
            
        # Apply morphological operations to clean the text
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2,2))
        gray = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, kernel)
        
        # Enhance contrast
        gray = cv2.equalizeHist(gray)
        
        # Binarize
        _, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        
        return binary
backend/database.py
python
import sqlite3
import logging
from datetime import datetime

class DatabaseManager:
    def __init__(self, db_path='society_vehicles.db'):
        self.db_path = db_path
        self.logger = logging.getLogger(__name__)
        self.init_database()
        
    def init_database(self):
        """Initialize database with enhanced schema"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Vehicle owners table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vehicle_owners (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                owner_name TEXT NOT NULL,
                license_plate TEXT UNIQUE NOT NULL,
                apartment_number TEXT,
                contact_phone TEXT,
                whatsapp_number TEXT,
                telegram_chat_id TEXT,
                email TEXT,
                is_authorized BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Vehicle logs table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vehicle_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                license_plate TEXT,
                detected_plate TEXT,
                confidence REAL,
                accuracy REAL,
                is_authorized BOOLEAN,
                image_path TEXT,
                weather_conditions TEXT,
                processing_time REAL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (license_plate) REFERENCES vehicle_owners (license_plate)
            )
        ''')
        
        # System performance table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS system_performance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                test_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                total_tests INTEGER,
                successful_detections INTEGER,
                average_accuracy REAL,
                average_processing_time REAL,
                weather_conditions TEXT
            )
        ''')
        
        conn.commit()
        conn.close()
        self.logger.info("Database initialized successfully")
        
    def add_vehicle_owner(self, owner_name, license_plate, apartment_number, 
                         contact_phone, whatsapp_number=None, telegram_chat_id=None, email=None):
        """Add a new vehicle owner to the database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                INSERT INTO vehicle_owners 
                (owner_name, license_plate, apartment_number, contact_phone, whatsapp_number, telegram_chat_id, email)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (owner_name, license_plate, apartment_number, contact_phone, whatsapp_number, telegram_chat_id, email))
            
            conn.commit()
            self.logger.info(f"Added vehicle owner: {owner_name} - {license_plate}")
            return True
            
        except sqlite3.IntegrityError:
            self.logger.warning(f"License plate already exists: {license_plate}")
            return False
        finally:
            conn.close()
            
    def verify_license_plate(self, license_plate):
        """Verify if a license plate is authorized"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT owner_name, apartment_number, contact_phone, whatsapp_number, telegram_chat_id, email
            FROM vehicle_owners 
            WHERE license_plate = ? AND is_authorized = 1
        ''', (license_plate,))
        
        result = cursor.fetchone()
        conn.close()
        
        if result:
            return {
                'owner_name': result[0],
                'apartment_number': result[1],
                'contact_phone': result[2],
                'whatsapp_number': result[3],
                'telegram_chat_id': result[4],
                'email': result[5],
                'is_authorized': True
            }
        return {'is_authorized': False}
        
    def log_vehicle_detection(self, license_plate, detected_plate, confidence, 
                            accuracy, is_authorized, image_path, weather_conditions, processing_time):
        """Log vehicle detection event"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO vehicle_logs 
            (license_plate, detected_plate, confidence, accuracy, is_authorized, image_path, weather_conditions, processing_time)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (license_plate, detected_plate, confidence, accuracy, is_authorized, image_path, weather_conditions, processing_time))
        
        conn.commit()
        conn.close()
        
    def get_performance_stats(self):
        """Get system performance statistics"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT 
                COUNT(*) as total_detections,
                AVG(accuracy) as avg_accuracy,
                AVG(processing_time) as avg_processing_time,
                COUNT(CASE WHEN is_authorized = 1 THEN 1 END) as authorized_count,
                COUNT(CASE WHEN is_authorized = 0 THEN 1 END) as unauthorized_count
            FROM vehicle_logs
        ''')
        
        result = cursor.fetchone()
        conn.close()
        
        return {
            'total_detections': result[0],
            'average_accuracy': round(result[1] or 0, 2),
            'average_processing_time': round(result[2] or 0, 2),
            'authorized_vehicles': result[3],
            'unauthorized_vehicles': result[4]
        }
backend/notification_service.py
python
import requests
import logging
from twilio.rest import Client
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart

class NotificationService:
    def __init__(self, twilio_account_sid=None, twilio_auth_token=None, 
                 telegram_bot_token=None, smtp_server=None, smtp_port=None,
                 email_sender=None, email_password=None):
        
        self.logger = logging.getLogger(__name__)
        
        # Twilio configuration (WhatsApp)
        self.twilio_client = None
        if twilio_account_sid and twilio_auth_token:
            self.twilio_client = Client(twilio_account_sid, twilio_auth_token)
            self.twilio_whatsapp_from = 'whatsapp:+14155238886'  # Twilio sandbox number
            
        # Telegram configuration
        self.telegram_bot_token = telegram_bot_token
        
        # Email configuration
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.email_sender = email_sender
        self.email_password = email_password
        
    def send_whatsapp_message(self, to_number, message):
        """Send WhatsApp message using Twilio"""
        if not self.twilio_client:
            self.logger.warning("Twilio not configured")
            return False
            
        try:
            message = self.twilio_client.messages.create(
                from_=self.twilio_whatsapp_from,
                body=message,
                to=f'whatsapp:{to_number}'
            )
            self.logger.info(f"WhatsApp message sent to {to_number}: {message.sid}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to send WhatsApp message: {str(e)}")
            return False
            
    def send_telegram_message(self, chat_id, message):
        """Send Telegram message"""
        if not self.telegram_bot_token:
            self.logger.warning("Telegram not configured")
            return False
            
        try:
            url = f"https://api.telegram.org/bot{self.telegram_bot_token}/sendMessage"
            data = {
                "chat_id": chat_id,
                "text": message,
                "parse_mode": "HTML"
            }
            
            response = requests.post(url, data=data)
            if response.status_code == 200:
                self.logger.info(f"Telegram message sent to {chat_id}")
                return True
            else:
                self.logger.error(f"Telegram API error: {response.text}")
                return False
                
        except Exception as e:
            self.logger.error(f"Failed to send Telegram message: {str(e)}")
            return False
            
    def send_email(self, to_email, subject, message):
        """Send email notification"""
        if not all([self.smtp_server, self.smtp_port, self.email_sender, self.email_password]):
            self.logger.warning("Email not configured")
            return False
            
        try:
            msg = MimeMultipart()
            msg['From'] = self.email_sender
            msg['To'] = to_email
            msg['Subject'] = subject
            
            msg.attach(MimeText(message, 'plain'))
            
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.email_sender, self.email_password)
            text = msg.as_string()
            server.sendmail(self.email_sender, to_email, text)
            server.quit()
            
            self.logger.info(f"Email sent to {to_email}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to send email: {str(e)}")
            return False
            
    def send_vehicle_notification(self, vehicle_info, detection_info, is_authorized):
        """Send comprehensive vehicle detection notification"""
        plate_text = detection_info['detected_plate']
        confidence = detection_info['confidence']
        accuracy = detection_info['accuracy']
        
        if is_authorized:
            message = f"""
ðŸš— Vehicle Detection Alert - AUTHORIZED

License Plate: {plate_text}
Owner: {vehicle_info['owner_name']}
Apartment: {vehicle_info['apartment_number']}
Detection Confidence: {confidence:.1f}%
Accuracy: {accuracy:.1f}%
Time: {detection_info['timestamp']}

Your vehicle has been detected at the society entrance.
            """
        else:
            message = f"""
ðŸš¨ VEHICLE SECURITY ALERT - UNAUTHORIZED

License Plate: {plate_text}
Detection Confidence: {confidence:.1f}%
Accuracy: {accuracy:.1f}%
Time: {detection_info['timestamp']}

âš ï¸ Unauthorized vehicle detected at society entrance!
Security has been notified.
            """
            
        # Send notifications based on available contact methods
        notifications_sent = 0
        
        if vehicle_info.get('whatsapp_number'):
            if self.send_whatsapp_message(vehicle_info['whatsapp_number'], message):
                notifications_sent += 1
                
        if vehicle_info.get('telegram_chat_id'):
            if self.send_telegram_message(vehicle_info['telegram_chat_id'], message):
                notifications_sent += 1
                
        if vehicle_info.get('email'):
            subject = "Vehicle Detection Alert" if is_authorized else "SECURITY ALERT - Unauthorized Vehicle"
            if self.send_email(vehicle_info['email'], subject, message):
                notifications_sent += 1
                
        self.logger.info(f"Sent {notifications_sent} notifications for vehicle {plate_text}")
        return notifications_sent > 0
backend/main.py
python
from flask import Flask, request, jsonify
from flask_cors import CORS
import os
from datetime import datetime
from lpr_system import LicensePlateRecognition
from database import DatabaseManager
from notification_service import NotificationService

app = Flask(__name__)
CORS(app)

# Initialize components
lpr_system = LicensePlateRecognition()
db_manager = DatabaseManager()
notification_service = NotificationService(
    twilio_account_sid=os.getenv('TWILIO_ACCOUNT_SID'),
    twilio_auth_token=os.getenv('TWILIO_AUTH_TOKEN'),
    telegram_bot_token=os.getenv('TELEGRAM_BOT_TOKEN'),
    smtp_server=os.getenv('SMTP_SERVER'),
    smtp_port=os.getenv('SMTP_PORT'),
    email_sender=os.getenv('EMAIL_SENDER'),
    email_password=os.getenv('EMAIL_PASSWORD')
)

@app.route('/api/detect-license-plate', methods=['POST'])
def detect_license_plate():
    """API endpoint for license plate detection"""
    try:
        if 'image' not in request.files:
            return jsonify({'error': 'No image provided'}), 400
            
        image_file = request.files['image']
        weather_condition = request.form.get('weather_condition', 'normal')
        expected_plate = request.form.get('expected_plate', '')
        
        # Save uploaded image
        image_path = f"uploads/{datetime.now().strftime('%Y%m%d_%H%M%S')}_{image_file.filename}"
        os.makedirs('uploads', exist_ok=True)
        image_file.save(image_path)
        
        start_time = time.time()
        
        # Detect license plate
        enhance_for_weather = weather_condition in ['foggy', 'misty', 'rainy']
        original_image, detected_plate, plate_contour = lpr_system.detect_license_plate(
            image_path, enhance_for_weather
        )
        
        processing_time = time.time() - start_time
        
        if detected_plate is None:
            return jsonify({
                'success': False,
                'message': 'No license plate detected',
                'processing_time': round(processing_time, 2)
            }), 400
            
        # Extract text from plate
        detected_text, confidence = lpr_system.extract_text_from_plate(detected_plate)
        
        # Calculate accuracy if expected plate is provided
        accuracy = lpr_system.calculate_accuracy(detected_text, expected_plate) if expected_plate else 0
        
        # Verify against database
        verification_result = db_manager.verify_license_plate(detected_text)
        is_authorized = verification_result['is_authorized']
        
        # Log detection
        db_manager.log_vehicle_detection(
            license_plate=detected_text,
            detected_plate=detected_text,
            confidence=confidence,
            accuracy=accuracy,
            is_authorized=is_authorized,
            image_path=image_path,
            weather_conditions=weather_condition,
            processing_time=processing_time
        )
        
        # Send notifications if vehicle is in database
        if is_authorized and verification_result.get('owner_name'):
            detection_info = {
                'detected_plate': detected_text,
                'confidence': confidence,
                'accuracy': accuracy,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            notification_service.send_vehicle_notification(verification_result, detection_info, True)
        
        response_data = {
            'success': True,
            'detected_plate': detected_text,
            'confidence': round(confidence, 2),
            'accuracy': round(accuracy, 2),
            'is_authorized': is_authorized,
            'processing_time': round(processing_time, 2),
            'weather_condition': weather_condition,
            'vehicle_info': verification_result if is_authorized else None
        }
        
        return jsonify(response_data)
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/performance-stats', methods=['GET'])
def get_performance_stats():
    """Get system performance statistics"""
    try:
        stats = db_manager.get_performance_stats()
        return jsonify(stats)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/add-vehicle', methods=['POST'])
def add_vehicle():
    """Add a new vehicle to the database"""
    try:
        data = request.json
        success = db_manager.add_vehicle_owner(
            owner_name=data['owner_name'],
            license_plate=data['license_plate'],
            apartment_number=data['apartment_number'],
            contact_phone=data['contact_phone'],
            whatsapp_number=data.get('whatsapp_number'),
            telegram_chat_id=data.get('telegram_chat_id'),
            email=data.get('email')
        )
        
        return jsonify({'success': success})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    os.makedirs('uploads', exist_ok=True)
    app.run(debug=True, host='0.0.0.0', port=5000)
2. Enhanced Test Script with Accuracy Measurement
backend/test_enhanced.py
python
import cv2
import numpy as np
import time
import matplotlib.pyplot as plt
import os
from lpr_system import LicensePlateRecognition
from database import DatabaseManager

def comprehensive_test():
    """Comprehensive test with accuracy measurement"""
    lpr = LicensePlateRecognition()
    db = DatabaseManager()
    
    # Test dataset with expected results
    test_cases = [
        {
            'image_path': 'test_images/clear_plate1.jpg',
            'expected_plate': 'ABC1234',
            'weather': 'normal'
        },
        {
            'image_path': 'test_images/foggy_plate1.jpg', 
            'expected_plate': 'XYZ5678',
            'weather': 'foggy'
        },
        {
            'image_path': 'test_images/dark_plate1.jpg',
            'expected_plate': 'LMN9012',
            'weather': 'dark'
        }
    ]
    
    results = []
    
    for test_case in test_cases:
        if not os.path.exists(test_case['image_path']):
            print(f"Image not found: {test_case['image_path']}")
            continue
            
        print(f"\nTesting: {test_case['image_path']}")
        print(f"Expected: {test_case['expected_plate']}")
        
        start_time = time.time()
        
        # Detect license plate
        enhance_for_weather = test_case['weather'] in ['foggy', 'misty']
        original, plate, contour = lpr.detect_license_plate(
            test_case['image_path'], enhance_for_weather
        )
        
        processing_time = time.time() - start_time
        
        if plate is not None:
            # Extract text
            detected_text, confidence = lpr.extract_text_from_plate(plate)
            accuracy = lpr.calculate_accuracy(detected_text, test_case['expected_plate'])
            
            print(f"Detected: {detected_text}")
            print(f"Confidence: {confidence:.2f}%")
            print(f"Accuracy: {accuracy:.2f}%")
            print(f"Processing Time: {processing_time:.2f}s")
            
            # Display results
            cv2.imshow('Original', original)
            cv2.imshow('Detected Plate', plate)
            cv2.waitKey(500)
            cv2.destroyAllWindows()
            
            results.append({
                'image': test_case['image_path'],
                'expected': test_case['expected_plate'],
                'detected': detected_text,
                'confidence': confidence,
                'accuracy': accuracy,
                'processing_time': processing_time,
                'weather': test_case['weather']
            })
            
        else:
            print("No license plate detected")
            results.append({
                'image': test_case['image_path'],
                'expected': test_case['expected_plate'],
                'detected': '',
                'confidence': 0,
                'accuracy': 0,
                'processing_time': processing_time,
                'weather': test_case['weather']
            })
    
    # Generate performance report
    generate_performance_report(results)
    
    return results

def generate_performance_report(results):
    """Generate comprehensive performance report"""
    if not results:
        print("No results to report")
        return
        
    # Calculate statistics
    successful_detections = [r for r in results if r['detected']]
    detection_rate = len(successful_detections) / len(results) * 100
    
    if successful_detections:
        avg_accuracy = np.mean([r['accuracy'] for r in successful_detections])
        avg_confidence = np.mean([r['confidence'] for r in successful_detections])
        avg_processing_time = np.mean([r['processing_time'] for r in results])
    else:
        avg_accuracy = avg_confidence = avg_processing_time = 0
    
    print("\n" + "="*50)
    print("PERFORMANCE REPORT")
    print("="*50)
    print(f"Total Tests: {len(results)}")
    print(f"Detection Rate: {detection_rate:.1f}%")
    print(f"Average Accuracy: {avg_accuracy:.1f}%")
    print(f"Average Confidence: {avg_confidence:.1f}%")
    print(f"Average Processing Time: {avg_processing_time:.2f}s")
    
    # Weather-specific performance
    weather_groups = {}
    for result in results:
        weather = result['weather']
        if weather not in weather_groups:
            weather_groups[weather] = []
        weather_groups[weather].append(result)
    
    print("\nWeather-specific Performance:")
    for weather, group_results in weather_groups.items():
        group_successful = [r for r in group_results if r['detected']]
        group_detection_rate = len(group_successful) / len(group_results) * 100
        group_avg_accuracy = np.mean([r['accuracy'] for r in group_successful]) if group_successful else 0
        
        print(f"  {weather.upper()}:")
        print(f"    Detection Rate: {group_detection_rate:.1f}%")
        print(f"    Average Accuracy: {group_avg_accuracy:.1f}%")
    
    # Plot results
    plot_performance_charts(results)

def plot_performance_charts(results):
    """Plot performance charts"""
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
    
    # Accuracy vs Processing Time
    accuracies = [r['accuracy'] for r in results if r['detected']]
    processing_times = [r['processing_time'] for r in results if r['detected']]
    ax1.scatter(processing_times, accuracies, alpha=0.7)
    ax1.set_xlabel('Processing Time (s)')
    ax1.set_ylabel('Accuracy (%)')
    ax1.set_title('Accuracy vs Processing Time')
    
    # Confidence Distribution
    confidences = [r['confidence'] for r in results if r['detected']]
    ax2.hist(confidences, bins=10, alpha=0.7, edgecolor='black')
    ax2.set_xlabel('Confidence (%)')
    ax2.set_ylabel('Frequency')
    ax2.set_title('Confidence Distribution')
    
    # Weather Performance
    weather_data = {}
    for result in results:
        weather = result['weather']
        if weather not in weather_data:
            weather_data[weather] = []
        if result['detected']:
            weather_data[weather].append(result['accuracy'])
    
    weather_names = list(weather_data.keys())
    weather_accuracies = [np.mean(accuracies) if accuracies else 0 for accuracies in weather_data.values()]
    bars = ax3.bar(weather_names, weather_accuracies, alpha=0.7)
    ax3.set_ylabel('Average Accuracy (%)')
    ax3.set_title('Accuracy by Weather Condition')
    
    # Add value labels on bars
    for bar, accuracy in zip(bars, weather_accuracies):
        ax3.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5, 
                f'{accuracy:.1f}%', ha='center', va='bottom')
    
    # Detection Results
    detected = len([r for r in results if r['detected']])
    not_detected = len(results) - detected
    ax4.pie([detected, not_detected], labels=['Detected', 'Not Detected'], 
            autopct='%1.1f%%', startangle=90)
    ax4.set_title('Detection Rate')
    
    plt.tight_layout()
    plt.savefig('performance_report.png', dpi=300, bbox_inches='tight')
    plt.show()

if __name__ == "__main__":
    comprehensive_test()
3. Setup and Configuration
backend/setup_enhanced_db.py
python
import sqlite3
from database import DatabaseManager

def setup_enhanced_database():
    """Setup enhanced database with sample data"""
    db = DatabaseManager()
    
    # Add sample vehicle owners with contact information
    sample_vehicles = [
        {
            'owner_name': 'John Doe',
            'license_plate': 'ABC1234',
            'apartment_number': 'A-101',
            'contact_phone': '+1234567890',
            'whatsapp_number': '+1234567890',
            'telegram_chat_id': '123456789',
            'email': 'john.doe@example.com'
        },
        {
            'owner_name': 'Jane Smith', 
            'license_plate': 'XYZ5678',
            'apartment_number': 'B-202',
            'contact_phone': '+1234567891',
            'whatsapp_number': '+1234567891',
            'telegram_chat_id': '987654321',
            'email': 'jane.smith@example.com'
        },
        {
            'owner_name': 'Alice Brown',
            'license_plate': 'LMN9012',
            'apartment_number': 'C-303',
            'contact_phone': '+1234567892',
            'whatsapp_number': '+1234567892',
            'email': 'alice.brown@example.com'
        }
    ]
    
    for vehicle in sample_vehicles:
        db.add_vehicle_owner(**vehicle)
    
    print("Enhanced database setup completed!")

if __name__ == "__main__":
    setup_enhanced_database()
4. Environment Configuration
backend/.env.example
env
# Twilio Configuration (for WhatsApp)
TWILIO_ACCOUNT_SID=your_twilio_account_sid
TWILIO_AUTH_TOKEN=your_twilio_auth_token

# Telegram Configuration
TELEGRAM_BOT_TOKEN=your_telegram_bot_token

# Email Configuration
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
EMAIL_SENDER=your_email@gmail.com
EMAIL_PASSWORD=your_app_password

# Application Configuration
DEBUG=True
UPLOAD_FOLDER=uploads
MAX_CONTENT_LENGTH=16777216  # 16MB
Key Features Implemented:
1. Accuracy Measurement
Character-level accuracy calculation using Levenshtein distance

Confidence scoring for OCR results

Comprehensive performance reporting

2. Weather Adaptation
Fog/mist enhancement using CLAHE and simplified dehazing

Multiple preprocessing strategies for different conditions

Weather-specific performance tracking

3. Multi-Platform Notifications
WhatsApp integration via Twilio

Telegram bot notifications

Email alerts

Configurable notification preferences

4. Enhanced Detection
Multiple detection strategies (contour, edge, morphology)

Confidence-based plate selection

Advanced image preprocessing

5. Comprehensive Database
Extended vehicle information

Performance logging

Contact management for notifications

To Run the System:
Install dependencies:

bash
pip install -r backend/requirements.txt
Setup database:

bash
python backend/setup_enhanced_db.py
Configure environment variables:

bash
cp backend/.env.example backend/.env
# Edit with your actual API keys
Run the system:

bash
python backend/main.py
Test with comprehensive evaluation:

bash
python backend/test_enhanced.py